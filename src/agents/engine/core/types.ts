/**
 * Agentic Engine - Domain Types
 *
 * Core type definitions for the Agentic Loop Engine.
 * These types define the contract between all layers of the system.
 */

// =============================================================================
// Agent State
// =============================================================================

/**
 * Possible phases of the agentic loop
 */
export type AgentPhase =
  | 'idle'
  | 'thinking'
  | 'planning'
  | 'awaiting_approval'
  | 'executing'
  | 'observing'
  | 'completed'
  | 'failed'
  | 'aborted';

/**
 * Risk level classification for operations
 */
export type RiskLevel = 'low' | 'medium' | 'high' | 'critical';

/**
 * Complete state of an agent session
 */
export interface AgentState {
  /** Unique session identifier */
  sessionId: string;
  /** Current phase of the agentic loop */
  phase: AgentPhase;
  /** Current iteration number */
  iteration: number;
  /** Maximum allowed iterations */
  maxIterations: number;
  /** Original user input */
  input: string;
  /** Current execution context */
  context: AgentContext;
  /** Result of the Think phase */
  thought: Thought | null;
  /** Result of the Plan phase */
  plan: Plan | null;
  /** History of all executions */
  executionHistory: ExecutionRecord[];
  /** Error if session failed */
  error: Error | null;
  /** Session start timestamp */
  startedAt: number;
  /** Session completion timestamp */
  completedAt: number | null;
}

// =============================================================================
// Think Phase Types
// =============================================================================

/**
 * Result of the Think phase - understanding user intent
 */
export interface Thought {
  /** Summary of what the user wants */
  understanding: string;
  /** List of requirements or preconditions */
  requirements: string[];
  /** List of uncertain aspects */
  uncertainties: string[];
  /** Planned approach to solve the request */
  approach: string;
  /** Whether more information is needed from user */
  needsMoreInfo: boolean;
  /** Question to ask user if more info needed */
  clarificationQuestion?: string;
}

// =============================================================================
// Plan Phase Types
// =============================================================================

/**
 * Execution plan generated by the Planner
 */
export interface Plan {
  /** The overall goal of the plan */
  goal: string;
  /** Ordered list of steps to execute */
  steps: PlanStep[];
  /** Total estimated duration in milliseconds */
  estimatedTotalDuration: number;
  /** Whether user approval is required before execution */
  requiresApproval: boolean;
  /** Strategy for rolling back if execution fails */
  rollbackStrategy: string;
}

/**
 * A single step in the execution plan
 */
export interface PlanStep {
  /** Unique step identifier */
  id: string;
  /** Tool name to execute */
  tool: string;
  /** Arguments to pass to the tool */
  args: Record<string, unknown>;
  /** Human-readable description */
  description: string;
  /** Risk level of this step */
  riskLevel: RiskLevel;
  /** Estimated duration in milliseconds */
  estimatedDuration: number;
  /** IDs of steps that must complete first */
  dependsOn?: string[];
  /** Whether this step can be skipped on failure */
  optional?: boolean;
  /** Alternative step if this one fails */
  fallback?: PlanStep;
}

// =============================================================================
// Execute Phase Types
// =============================================================================

/**
 * An action to be executed
 */
export interface Action {
  /** Reference to the plan step */
  stepId: string;
  /** Tool name */
  tool: string;
  /** Tool arguments */
  args: Record<string, unknown>;
}

/**
 * Result of executing a tool
 */
export interface ToolResult {
  /** Whether execution succeeded */
  success: boolean;
  /** Result data if successful */
  data?: unknown;
  /** Error message if failed */
  error?: string;
  /** Execution duration in milliseconds */
  duration: number;
}

/**
 * Record of an execution for history tracking
 */
export interface ExecutionRecord {
  /** The action that was executed */
  action: Action;
  /** Result of the execution */
  result: ToolResult;
  /** Timestamp of execution */
  timestamp: number;
}

// =============================================================================
// Observe Phase Types
// =============================================================================

/**
 * Observation after executing a plan
 */
export interface Observation {
  /** Whether the original goal was achieved */
  goalAchieved: boolean;
  /** List of state changes that occurred */
  stateChanges: StateChange[];
  /** Human-readable summary of what happened */
  summary: string;
  /** Confidence level in the observation (0-1) */
  confidence: number;
  /** Whether another iteration is recommended */
  needsIteration: boolean;
  /** Reason for recommending iteration (if needsIteration) */
  iterationReason?: string;
  /** Suggested action for next iteration (if needsIteration) */
  suggestedAction?: string;
}

/**
 * A change to the project state
 */
export interface StateChange {
  /** Type of change (e.g., clip_created, clip_modified, track_deleted) */
  type: string;
  /** ID of the affected entity */
  target: string;
  /** Additional details about the change */
  details?: Record<string, unknown>;
}

// =============================================================================
// Event Types
// =============================================================================

/**
 * Events emitted during agent execution
 */
export type AgentEvent =
  | SessionStartEvent
  | ThinkingStartEvent
  | ThinkingProgressEvent
  | ThinkingCompleteEvent
  | PlanningStartEvent
  | PlanningProgressEvent
  | PlanningCompleteEvent
  | ApprovalRequiredEvent
  | ApprovalResponseEvent
  | ExecutionStartEvent
  | ExecutionProgressEvent
  | ExecutionCompleteEvent
  | ObservationCompleteEvent
  | IterationCompleteEvent
  | SessionCompleteEvent
  | SessionFailedEvent
  | SessionAbortedEvent;

export interface SessionStartEvent {
  type: 'session_start';
  sessionId: string;
  input: string;
  timestamp: number;
}

export interface ThinkingStartEvent {
  type: 'thinking_start';
  timestamp: number;
}

export interface ThinkingProgressEvent {
  type: 'thinking_progress';
  partial: string;
  timestamp: number;
}

export interface ThinkingCompleteEvent {
  type: 'thinking_complete';
  thought: Thought;
  timestamp: number;
}

export interface PlanningStartEvent {
  type: 'planning_start';
  timestamp: number;
}

export interface PlanningProgressEvent {
  type: 'planning_progress';
  partial: string;
  timestamp: number;
}

export interface PlanningCompleteEvent {
  type: 'planning_complete';
  plan: Plan;
  timestamp: number;
}

export interface ApprovalRequiredEvent {
  type: 'approval_required';
  plan: Plan;
  timestamp: number;
}

export interface ApprovalResponseEvent {
  type: 'approval_response';
  approved: boolean;
  reason?: string;
  timestamp: number;
}

export interface ExecutionStartEvent {
  type: 'execution_start';
  step: PlanStep;
  timestamp: number;
}

export interface ExecutionProgressEvent {
  type: 'execution_progress';
  step: PlanStep;
  progress: number;
  timestamp: number;
}

export interface ExecutionCompleteEvent {
  type: 'execution_complete';
  step: PlanStep;
  result: ToolResult;
  timestamp: number;
}

export interface ObservationCompleteEvent {
  type: 'observation_complete';
  observation: Observation;
  timestamp: number;
}

export interface IterationCompleteEvent {
  type: 'iteration_complete';
  iteration: number;
  timestamp: number;
}

export interface SessionCompleteEvent {
  type: 'session_complete';
  summary: SessionSummary;
  timestamp: number;
}

export interface SessionFailedEvent {
  type: 'session_failed';
  error: Error;
  timestamp: number;
}

export interface SessionAbortedEvent {
  type: 'session_aborted';
  reason: string;
  timestamp: number;
}

/**
 * Summary of a completed session
 */
export interface SessionSummary {
  /** Session identifier */
  sessionId: string;
  /** Original user input */
  input: string;
  /** Total iterations completed */
  totalIterations: number;
  /** Number of steps executed */
  executedSteps: number;
  /** Number of successful steps */
  successfulSteps: number;
  /** Number of failed steps */
  failedSteps: number;
  /** Total duration in milliseconds */
  duration: number;
  /** Final state description */
  finalState: string;
}

// =============================================================================
// Context Types
// =============================================================================

/**
 * Timeline information for context
 */
export interface TimelineInfo {
  /** Timeline duration in seconds */
  duration: number;
  /** Number of tracks */
  trackCount: number;
  /** Number of clips */
  clipCount?: number;
}

/**
 * Clip information for context
 */
export interface ClipInfo {
  /** Clip identifier */
  id: string;
  /** Clip name */
  name: string;
  /** Track the clip is on */
  trackId: string;
  /** Start time in seconds */
  startTime: number;
  /** End time in seconds */
  endTime: number;
  /** Duration in seconds */
  duration: number;
}

/**
 * Context information for agent execution
 */
export interface AgentContext {
  // Project context
  /** Project identifier */
  projectId: string;
  /** Sequence identifier */
  sequenceId?: string;

  // Timeline state
  /** Current playhead position in seconds */
  playheadPosition: number;
  /** Total timeline duration in seconds */
  timelineDuration: number;
  /** List of selected clip IDs */
  selectedClips: string[];
  /** List of selected track IDs */
  selectedTracks: string[];
  /** Detailed timeline information */
  timelineInfo?: TimelineInfo;

  // Available resources
  /** Available assets */
  availableAssets: AssetInfo[];
  /** Available tracks */
  availableTracks: TrackInfo[];
  /** Available tool names */
  availableTools: string[];

  // Iteration tracking
  /** Current iteration number */
  currentIteration?: number;

  // Memory (from MemoryManager)
  /** Recent operations for pattern learning */
  recentOperations: OperationRecord[];
  /** User preferences */
  userPreferences: Record<string, unknown>;
  /** User corrections for learning */
  corrections: CorrectionRecord[];
}

/**
 * Information about an available asset
 */
export interface AssetInfo {
  /** Asset identifier */
  id: string;
  /** Asset display name */
  name: string;
  /** Asset type */
  type: 'video' | 'audio' | 'image';
  /** Duration in seconds (for video/audio) */
  duration?: number;
}

/**
 * Information about a track
 */
export interface TrackInfo {
  /** Track identifier */
  id: string;
  /** Track display name */
  name: string;
  /** Track type */
  type: 'video' | 'audio';
  /** Number of clips on this track */
  clipCount: number;
}

/**
 * Record of a frequently used operation
 */
export interface OperationRecord {
  /** Operation name */
  operation: string;
  /** Usage count */
  count: number;
  /** Last used timestamp */
  lastUsed: number;
}

/**
 * Record of a user correction for learning
 */
export interface CorrectionRecord {
  /** Original agent output */
  original: string;
  /** User's correction */
  corrected: string;
  /** Context when correction was made */
  context?: string;
}

// =============================================================================
// Configuration Types
// =============================================================================

/**
 * Configuration for the Agentic Engine
 */
export interface AgenticEngineConfig {
  /** Maximum iterations before giving up (default: 20) */
  maxIterations: number;
  /** Timeout for thinking phase in ms (default: 30000) */
  thinkingTimeout: number;
  /** Timeout for planning phase in ms (default: 30000) */
  planningTimeout: number;
  /** Timeout for execution phase in ms (default: 60000) */
  executionTimeout: number;
  /** Timeout for observation phase in ms (default: 15000) */
  observationTimeout: number;

  /** Enable streaming output (default: true) */
  enableStreaming: boolean;
  /** Enable memory system (default: true) */
  enableMemory: boolean;
  /** Enable checkpoints (default: true) */
  enableCheckpoints: boolean;

  /** Minimum risk level requiring approval (default: 'high') */
  approvalThreshold: RiskLevel;
  /** Auto retry on failure (default: true) */
  autoRetryOnFailure: boolean;
  /** Maximum retry attempts (default: 2) */
  maxRetries: number;

  /**
   * Optional approval handler for human-in-the-loop workflows.
   *
   * If provided, the engine will pause when a plan requires approval and await
   * this handler's response before proceeding.
   */
  approvalHandler?: (plan: Plan) => Promise<boolean>;

  /** Stop execution on the first tool error (default: true) */
  stopOnError?: boolean;
}

/**
 * Default configuration values
 */
export const DEFAULT_ENGINE_CONFIG: AgenticEngineConfig = {
  maxIterations: 20,
  thinkingTimeout: 30000,
  planningTimeout: 30000,
  executionTimeout: 60000,
  observationTimeout: 15000,
  enableStreaming: true,
  enableMemory: true,
  enableCheckpoints: true,
  approvalThreshold: 'high',
  autoRetryOnFailure: true,
  maxRetries: 2,
  stopOnError: true,
};

// =============================================================================
// Utility Types
// =============================================================================

/**
 * Creates a partial configuration with defaults
 */
export type PartialEngineConfig = Partial<AgenticEngineConfig>;

/**
 * Result of validating tool arguments
 */
export interface ValidationResult {
  valid: boolean;
  errors: string[];
}

/**
 * Side effect from tool execution
 */
export interface SideEffect {
  type: 'created' | 'modified' | 'deleted';
  entity: string;
  entityId: string;
}

// =============================================================================
// Factory Functions
// =============================================================================

/**
 * Create initial agent state
 */
export function createInitialState(
  sessionId: string,
  input: string,
  context: AgentContext,
  config: AgenticEngineConfig
): AgentState {
  return {
    sessionId,
    phase: 'idle',
    iteration: 0,
    maxIterations: config.maxIterations,
    input,
    context,
    thought: null,
    plan: null,
    executionHistory: [],
    error: null,
    startedAt: Date.now(),
    completedAt: null,
  };
}

/**
 * Create empty context for testing
 */
export function createEmptyContext(projectId: string): AgentContext {
  return {
    projectId,
    playheadPosition: 0,
    timelineDuration: 0,
    selectedClips: [],
    selectedTracks: [],
    availableAssets: [],
    availableTracks: [],
    availableTools: [],
    recentOperations: [],
    userPreferences: {},
    corrections: [],
  };
}

/**
 * Merge partial config with defaults
 */
export function mergeConfig(partial?: PartialEngineConfig): AgenticEngineConfig {
  return { ...DEFAULT_ENGINE_CONFIG, ...partial };
}

/**
 * Check if risk level requires approval
 */
export function requiresApproval(
  riskLevel: RiskLevel,
  threshold: RiskLevel
): boolean {
  const levels: RiskLevel[] = ['low', 'medium', 'high', 'critical'];
  return levels.indexOf(riskLevel) >= levels.indexOf(threshold);
}

/**
 * Generate unique ID
 */
export function generateId(prefix: string = ''): string {
  const id = crypto.randomUUID();
  return prefix ? `${prefix}_${id}` : id;
}
