/**
 * Agentic Engine - Domain Types
 *
 * Core type definitions for the Agentic Loop Engine.
 * These types define the contract between all layers of the system.
 */

import type { IMemoryStore } from '../ports/IMemoryStore';

// =============================================================================
// Agent State
// =============================================================================

/**
 * Possible phases of the agentic loop
 */
export type AgentPhase =
  | 'idle'
  | 'thinking'
  | 'planning'
  | 'awaiting_approval'
  | 'executing'
  | 'observing'
  | 'completed'
  | 'failed'
  | 'aborted';

/**
 * Risk level classification for operations
 */
export type RiskLevel = 'low' | 'medium' | 'high' | 'critical';

/**
 * Complete state of an agent session
 */
export interface AgentState {
  /** Unique session identifier */
  sessionId: string;
  /** Current phase of the agentic loop */
  phase: AgentPhase;
  /** Current iteration number */
  iteration: number;
  /** Maximum allowed iterations */
  maxIterations: number;
  /** Original user input */
  input: string;
  /** Current execution context */
  context: AgentContext;
  /** Result of the Think phase */
  thought: Thought | null;
  /** Result of the Plan phase */
  plan: Plan | null;
  /** History of all executions */
  executionHistory: ExecutionRecord[];
  /** Error if session failed */
  error: Error | null;
  /** Session start timestamp */
  startedAt: number;
  /** Session completion timestamp */
  completedAt: number | null;
}

// =============================================================================
// Think Phase Types
// =============================================================================

/**
 * Result of the Think phase - understanding user intent
 */
export interface Thought {
  /** Summary of what the user wants */
  understanding: string;
  /** List of requirements or preconditions */
  requirements: string[];
  /** List of uncertain aspects */
  uncertainties: string[];
  /** Planned approach to solve the request */
  approach: string;
  /** Whether more information is needed from user */
  needsMoreInfo: boolean;
  /** Question to ask user if more info needed */
  clarificationQuestion?: string;
}

// =============================================================================
// Plan Phase Types
// =============================================================================

/**
 * Execution plan generated by the Planner
 */
export interface Plan {
  /** The overall goal of the plan */
  goal: string;
  /** Ordered list of steps to execute */
  steps: PlanStep[];
  /** Total estimated duration in milliseconds */
  estimatedTotalDuration: number;
  /** Whether user approval is required before execution */
  requiresApproval: boolean;
  /** Strategy for rolling back if execution fails */
  rollbackStrategy: string;
}

/**
 * A single step in the execution plan
 */
export interface PlanStep {
  /** Unique step identifier */
  id: string;
  /** Tool name to execute */
  tool: string;
  /** Arguments to pass to the tool */
  args: Record<string, unknown>;
  /** Human-readable description */
  description: string;
  /** Risk level of this step */
  riskLevel: RiskLevel;
  /** Estimated duration in milliseconds */
  estimatedDuration: number;
  /** IDs of steps that must complete first */
  dependsOn?: string[];
  /** Whether this step can be skipped on failure */
  optional?: boolean;
  /** Alternative step if this one fails */
  fallback?: PlanStep;
}

// =============================================================================
// Execute Phase Types
// =============================================================================

/**
 * An action to be executed
 */
export interface Action {
  /** Reference to the plan step */
  stepId: string;
  /** Tool name */
  tool: string;
  /** Tool arguments */
  args: Record<string, unknown>;
}

/**
 * Result of executing a tool
 */
export interface ToolResult {
  /** Whether execution succeeded */
  success: boolean;
  /** Result data if successful */
  data?: unknown;
  /** Error message if failed */
  error?: string;
  /** Execution duration in milliseconds */
  duration: number;
}

/**
 * Record of an execution for history tracking
 */
export interface ExecutionRecord {
  /** The action that was executed */
  action: Action;
  /** Result of the execution */
  result: ToolResult;
  /** Timestamp of execution */
  timestamp: number;
}

/**
 * Failure details for rollback attempts.
 */
export interface RollbackFailure {
  /** Undo tool that failed */
  tool: string;
  /** Step ID associated with the original successful operation */
  sourceStepId: string;
  /** Failure reason */
  error: string;
}

/**
 * Report emitted when rollback recovery is attempted.
 */
export interface RollbackReport {
  /** Whether rollback was attempted */
  attempted: boolean;
  /** Total rollback candidates found */
  candidateCount: number;
  /** Number of rollback operations attempted */
  attemptedCount: number;
  /** Number of successful rollback operations */
  succeededCount: number;
  /** Number of failed rollback operations */
  failedCount: number;
  /** Number of skipped rollback operations (validation/missing tool) */
  skippedCount: number;
  /** Optional reason when rollback was skipped */
  reason?: string;
  /** Failure details for diagnostics */
  failures: RollbackFailure[];
}

// =============================================================================
// Observe Phase Types
// =============================================================================

/**
 * Observation after executing a plan
 */
export interface Observation {
  /** Whether the original goal was achieved */
  goalAchieved: boolean;
  /** List of state changes that occurred */
  stateChanges: StateChange[];
  /** Human-readable summary of what happened */
  summary: string;
  /** Confidence level in the observation (0-1) */
  confidence: number;
  /** Whether another iteration is recommended */
  needsIteration: boolean;
  /** Reason for recommending iteration (if needsIteration) */
  iterationReason?: string;
  /** Suggested action for next iteration (if needsIteration) */
  suggestedAction?: string;
}

/**
 * A change to the project state
 */
export interface StateChange {
  /** Type of change (e.g., clip_created, clip_modified, track_deleted) */
  type: string;
  /** ID of the affected entity */
  target: string;
  /** Additional details about the change */
  details?: Record<string, unknown>;
}

// =============================================================================
// Event Types
// =============================================================================

/**
 * Events emitted during agent execution
 */
export type AgentEvent =
  | SessionStartEvent
  | ThinkingStartEvent
  | ThinkingProgressEvent
  | ThinkingCompleteEvent
  | ClarificationRequiredEvent
  | PlanningStartEvent
  | PlanningProgressEvent
  | PlanningCompleteEvent
  | ApprovalRequiredEvent
  | ApprovalResponseEvent
  | ExecutionStartEvent
  | ExecutionProgressEvent
  | ExecutionCompleteEvent
  | ObservationCompleteEvent
  | IterationCompleteEvent
  | SessionCompleteEvent
  | SessionFailedEvent
  | SessionAbortedEvent;

export interface SessionStartEvent {
  type: 'session_start';
  sessionId: string;
  input: string;
  timestamp: number;
}

export interface ThinkingStartEvent {
  type: 'thinking_start';
  timestamp: number;
}

export interface ThinkingProgressEvent {
  type: 'thinking_progress';
  partial: string;
  timestamp: number;
}

export interface ThinkingCompleteEvent {
  type: 'thinking_complete';
  thought: Thought;
  timestamp: number;
}

export interface ClarificationRequiredEvent {
  type: 'clarification_required';
  question: string;
  thought: Thought;
  timestamp: number;
}

export interface PlanningStartEvent {
  type: 'planning_start';
  timestamp: number;
}

export interface PlanningProgressEvent {
  type: 'planning_progress';
  partial: string;
  timestamp: number;
}

export interface PlanningCompleteEvent {
  type: 'planning_complete';
  plan: Plan;
  timestamp: number;
}

export interface ApprovalRequiredEvent {
  type: 'approval_required';
  plan: Plan;
  timestamp: number;
}

export interface ApprovalResponseEvent {
  type: 'approval_response';
  approved: boolean;
  reason?: string;
  timestamp: number;
}

export interface ExecutionStartEvent {
  type: 'execution_start';
  step: PlanStep;
  timestamp: number;
}

export interface ExecutionProgressEvent {
  type: 'execution_progress';
  step: PlanStep;
  progress: number;
  timestamp: number;
}

export interface ExecutionCompleteEvent {
  type: 'execution_complete';
  step: PlanStep;
  result: ToolResult;
  timestamp: number;
}

export interface ObservationCompleteEvent {
  type: 'observation_complete';
  observation: Observation;
  timestamp: number;
}

export interface IterationCompleteEvent {
  type: 'iteration_complete';
  iteration: number;
  timestamp: number;
}

export interface SessionCompleteEvent {
  type: 'session_complete';
  summary: SessionSummary;
  timestamp: number;
}

export interface SessionFailedEvent {
  type: 'session_failed';
  error: Error;
  timestamp: number;
}

export interface SessionAbortedEvent {
  type: 'session_aborted';
  reason: string;
  timestamp: number;
}

/**
 * Summary of a completed session
 */
export interface SessionSummary {
  /** Session identifier */
  sessionId: string;
  /** Original user input */
  input: string;
  /** Total iterations completed */
  totalIterations: number;
  /** Number of steps executed */
  executedSteps: number;
  /** Number of successful steps */
  successfulSteps: number;
  /** Number of failed steps */
  failedSteps: number;
  /** Total duration in milliseconds */
  duration: number;
  /** Final state description */
  finalState: string;
  /** Failure reason when session ended unsuccessfully */
  failureReason?: string;
  /** Rollback report when recovery was attempted */
  rollbackReport?: RollbackReport;
}

// =============================================================================
// Context Types
// =============================================================================

/**
 * Timeline information for context
 */
export interface TimelineInfo {
  /** Timeline duration in seconds */
  duration: number;
  /** Number of tracks */
  trackCount: number;
  /** Number of clips */
  clipCount?: number;
}

/**
 * Clip information for context
 */
export interface ClipInfo {
  /** Clip identifier */
  id: string;
  /** Clip name */
  name: string;
  /** Track the clip is on */
  trackId: string;
  /** Start time in seconds */
  startTime: number;
  /** End time in seconds */
  endTime: number;
  /** Duration in seconds */
  duration: number;
}

/**
 * Context information for agent execution
 */
export interface AgentContext {
  // Project context
  /** Project identifier */
  projectId: string;
  /** Sequence identifier */
  sequenceId?: string;

  // Language policy
  /** Language policy for user-facing natural language output */
  languagePolicy?: LanguagePolicy;

  // Timeline state
  /** Current playhead position in seconds */
  playheadPosition: number;
  /** Total timeline duration in seconds */
  timelineDuration: number;
  /** List of selected clip IDs */
  selectedClips: string[];
  /** List of selected track IDs */
  selectedTracks: string[];
  /** Detailed timeline information */
  timelineInfo?: TimelineInfo;

  // Available resources
  /** Available assets */
  availableAssets: AssetInfo[];
  /** Available tracks */
  availableTracks: TrackInfo[];
  /** Available tool names */
  availableTools: string[];

  // Iteration tracking
  /** Current iteration number */
  currentIteration?: number;

  // Memory (from MemoryManager)
  /** Recent operations for pattern learning */
  recentOperations: OperationRecord[];
  /** User preferences */
  userPreferences: Record<string, unknown>;
  /** User corrections for learning */
  corrections: CorrectionRecord[];
}

/**
 * Language policy used by agent prompts.
 *
 * This policy controls how the agent generates natural language while keeping
 * structured command/tool identifiers language-agnostic.
 */
export interface LanguagePolicy {
  /** UI language configured in application settings (BCP-47-like tag) */
  uiLanguage: string;
  /** Default output language for natural-language fields */
  outputLanguage: string;
  /** Whether the model should infer input language from user text */
  detectInputLanguage: boolean;
  /** Whether users can override output language per message */
  allowUserLanguageOverride: boolean;
}

/**
 * Information about an available asset
 */
export interface AssetInfo {
  /** Asset identifier */
  id: string;
  /** Asset display name */
  name: string;
  /** Asset type */
  type: 'video' | 'audio' | 'image';
  /** Duration in seconds (for video/audio) */
  duration?: number;
}

/**
 * Information about a track
 */
export interface TrackInfo {
  /** Track identifier */
  id: string;
  /** Track display name */
  name: string;
  /** Track type */
  type: 'video' | 'audio';
  /** Number of clips on this track */
  clipCount: number;
}

/**
 * Record of a frequently used operation
 */
export interface OperationRecord {
  /** Operation name */
  operation: string;
  /** Usage count */
  count: number;
  /** Last used timestamp */
  lastUsed: number;
}

/**
 * Record of a user correction for learning
 */
export interface CorrectionRecord {
  /** Original agent output */
  original: string;
  /** User's correction */
  corrected: string;
  /** Context when correction was made */
  context?: string;
}

// =============================================================================
// Configuration Types
// =============================================================================

/**
 * Configuration for the Agentic Engine
 */
export interface AgenticEngineConfig {
  /** Maximum iterations before giving up (default: 20) */
  maxIterations: number;
  /** Timeout for thinking phase in ms (default: 60000) */
  thinkingTimeout: number;
  /** Timeout for planning phase in ms (default: 60000) */
  planningTimeout: number;
  /** Timeout for execution phase in ms (default: 60000) */
  executionTimeout: number;
  /** Timeout for observation phase in ms (default: 15000) */
  observationTimeout: number;

  /** Enable streaming output (default: true) */
  enableStreaming: boolean;
  /** Enable memory system (default: true) */
  enableMemory: boolean;
  /** Enable checkpoints (default: true) */
  enableCheckpoints: boolean;

  /** Minimum risk level requiring approval (default: 'high') */
  approvalThreshold: RiskLevel;
  /** Auto retry on failure (default: true) */
  autoRetryOnFailure: boolean;
  /** Maximum retry attempts (default: 2) */
  maxRetries: number;

  /** Enable deterministic fast-path parsing before Think/Plan (default: true) */
  enableFastPath: boolean;

  /** Minimum parser confidence required to execute fast path (default: 0.85) */
  fastPathConfidenceThreshold: number;

  /** Maximum total plan steps allowed per run across iterations (default: 60) */
  maxStepsPerRun: number;

  /** Maximum total tool calls allowed per run across iterations (default: 120) */
  maxToolCallsPerRun: number;

  /** Force approval when a plan contains destructive tools (default: true) */
  requireApprovalForDestructiveActions: boolean;

  /** Tool names considered destructive and requiring approval (default list) */
  destructiveToolNames: string[];

  /** Automatically attempt rollback when execution fails (default: true) */
  enableAutoRollbackOnFailure: boolean;

  /** Maximum rollback operations to attempt per failed run (default: 20) */
  maxRollbackSteps: number;

  /** Memory store adapter for operation/correction/preference retrieval */
  memoryStore?: IMemoryStore;

  /** Maximum recent operations loaded into context (default: 20) */
  memoryRecentOperationsLimit: number;

  /** Maximum corrections loaded into context (default: 20) */
  memoryCorrectionsLimit: number;

  /**
   * Optional approval handler for human-in-the-loop workflows.
   *
   * If provided, the engine will pause when a plan requires approval and await
   * this handler's response before proceeding.
   */
  approvalHandler?: (plan: Plan) => Promise<boolean>;

  /** Stop execution on the first tool error (default: true) */
  stopOnError?: boolean;

  /**
   * Optional callback to refresh context between iterations.
   *
   * When provided, the engine calls this at the start of each iteration
   * to get a fresh snapshot of project/timeline state from Zustand stores.
   * This prevents stale context in multi-step tasks where iteration N
   * modifies state that iteration N+1 needs to see.
   *
   * Returns a partial context â€” only the fields that changed need to be
   * included. Fields not present in the result are preserved from the
   * previous iteration. `availableTools` is always preserved from the
   * initial context regardless of what the refresher returns.
   */
  contextRefresher?: () => Partial<AgentContext> | Promise<Partial<AgentContext>>;
}

/**
 * Default configuration values
 */
export const DEFAULT_ENGINE_CONFIG: AgenticEngineConfig = {
  maxIterations: 20,
  thinkingTimeout: 60000,
  planningTimeout: 60000,
  executionTimeout: 60000,
  observationTimeout: 15000,
  enableStreaming: true,
  enableMemory: true,
  enableCheckpoints: true,
  approvalThreshold: 'high',
  autoRetryOnFailure: true,
  maxRetries: 2,
  stopOnError: true,
  enableFastPath: true,
  fastPathConfidenceThreshold: 0.85,
  maxStepsPerRun: 60,
  maxToolCallsPerRun: 120,
  requireApprovalForDestructiveActions: true,
  destructiveToolNames: [
    'delete_clip',
    'delete_clips_in_range',
    'delete_caption',
    'delete_all_clips',
    'remove_clip',
    'remove_transition',
    'remove_effect',
    'ripple_delete',
  ],
  enableAutoRollbackOnFailure: true,
  maxRollbackSteps: 20,
  memoryStore: undefined,
  memoryRecentOperationsLimit: 20,
  memoryCorrectionsLimit: 20,
};

// =============================================================================
// Utility Types
// =============================================================================

/**
 * Creates a partial configuration with defaults
 */
export type PartialEngineConfig = Partial<AgenticEngineConfig>;

/**
 * Result of validating tool arguments
 */
export interface ValidationResult {
  valid: boolean;
  errors: string[];
}

/**
 * Side effect from tool execution
 */
export interface SideEffect {
  type: 'created' | 'modified' | 'deleted';
  entity: string;
  entityId: string;
}

// =============================================================================
// Factory Functions
// =============================================================================

/**
 * Create initial agent state
 */
export function createInitialState(
  sessionId: string,
  input: string,
  context: AgentContext,
  config: AgenticEngineConfig,
): AgentState {
  return {
    sessionId,
    phase: 'idle',
    iteration: 0,
    maxIterations: config.maxIterations,
    input,
    context,
    thought: null,
    plan: null,
    executionHistory: [],
    error: null,
    startedAt: Date.now(),
    completedAt: null,
  };
}

/**
 * Create empty context for testing
 */
export function createEmptyContext(projectId: string): AgentContext {
  return {
    projectId,
    languagePolicy: createLanguagePolicy('en'),
    playheadPosition: 0,
    timelineDuration: 0,
    selectedClips: [],
    selectedTracks: [],
    availableAssets: [],
    availableTracks: [],
    availableTools: [],
    recentOperations: [],
    userPreferences: {},
    corrections: [],
  };
}

/**
 * Merge partial config with defaults
 */
export function mergeConfig(partial?: PartialEngineConfig): AgenticEngineConfig {
  return { ...DEFAULT_ENGINE_CONFIG, ...partial };
}

/**
 * Check if risk level requires approval
 */
export function requiresApproval(riskLevel: RiskLevel, threshold: RiskLevel): boolean {
  const levels: RiskLevel[] = ['low', 'medium', 'high', 'critical'];
  return levels.indexOf(riskLevel) >= levels.indexOf(threshold);
}

/**
 * Generate unique ID
 */
export function generateId(prefix: string = ''): string {
  const id = crypto.randomUUID();
  return prefix ? `${prefix}_${id}` : id;
}

/**
 * Normalize a user or settings language tag into a stable form.
 *
 * - Accepts `en`, `ko`, `es`, `en-US`, `zh-Hant`, etc.
 * - Converts underscores to hyphens.
 * - Falls back to `en` if input is invalid.
 */
export function normalizeLanguageCode(
  language: string | null | undefined,
  fallback: string = 'en',
): string {
  const normalizedFallback = normalizeLanguageCore(fallback, 'en');
  return normalizeLanguageCore(language, normalizedFallback);
}

/**
 * Create a language policy with normalized codes and safe defaults.
 */
export function createLanguagePolicy(
  uiLanguage: string,
  overrides: Partial<LanguagePolicy> = {},
): LanguagePolicy {
  const resolvedUiLanguage = normalizeLanguageCode(overrides.uiLanguage ?? uiLanguage);
  return {
    uiLanguage: resolvedUiLanguage,
    outputLanguage: normalizeLanguageCode(overrides.outputLanguage ?? resolvedUiLanguage),
    detectInputLanguage: overrides.detectInputLanguage ?? true,
    allowUserLanguageOverride: overrides.allowUserLanguageOverride ?? true,
  };
}

function normalizeLanguageCore(rawLanguage: string | null | undefined, fallback: string): string {
  if (!rawLanguage || typeof rawLanguage !== 'string') {
    return fallback;
  }

  const compact = rawLanguage.trim().replace(/_/g, '-');
  if (!compact) {
    return fallback;
  }

  const parts = compact.split('-').filter(Boolean);
  const primary = parts[0]?.toLowerCase();

  if (!primary || !/^[a-z]{2,3}$/.test(primary)) {
    return fallback;
  }

  const normalizedParts: string[] = [primary];
  for (let i = 1; i < parts.length; i += 1) {
    const part = parts[i];
    if (/^[a-zA-Z]{2}$/.test(part) || /^[0-9]{3}$/.test(part)) {
      normalizedParts.push(part.toUpperCase());
      continue;
    }

    if (i === 1 && /^[a-zA-Z]{4}$/.test(part)) {
      normalizedParts.push(part.charAt(0).toUpperCase() + part.slice(1).toLowerCase());
      continue;
    }

    if (/^[a-zA-Z0-9]{2,8}$/.test(part)) {
      normalizedParts.push(part.toLowerCase());
      continue;
    }

    return fallback;
  }

  return normalizedParts.join('-');
}
